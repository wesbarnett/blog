{
  
    
        "post0": {
            "title": "Classification Decision Trees",
            "content": "from sklearn.datasets import load_iris from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn import tree from sklearn.model_selection import train_test_split import graphviz import numpy as np from sklearn.tree import DecisionTreeRegressor import matplotlib.pyplot as plt . scikit-learn now comes with a way to plot trees, but I prefer using graphviz so here is a quick function to plot a tree, which we monkey-patch into the DecisionTreeClassifier and DecisionTreeRegressor classes. . def display_tree(self): dot_data = tree.export_graphviz(self, out_file=None, filled=True, rounded=True, special_characters=True) graph = graphviz.Source(dot_data) return graph DecisionTreeClassifier.plot = display_tree . Classification . We&#39;ll use the Iris dataset as a quick way to discuss classification trees. To learn more about this dataset use help(load_iris). . iris = load_iris() X = iris.data y = iris.target X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) . Fitting . Decision trees search over all possible ways to split up features and find the split that is most informative about the target variable. The parent node splits into two child nodes based on this split. From there the children also split in the same manner until all leaves are pure, unless another stopping condition is specified. A leaf is a node that has no children. A pure leaf is a leaf with only one class of items in it. . Classifications trees split using the GINI impurity which is defined as: . $I_{G}(p) = sum_{i=1}^{J}p_{i}(1-p_{i})$ . Here $p_{i}$ is the probability of an item with label $i$ being chosen and $1 - p_{i}$ is the probability of a mistake in categorizing that item. $J$ is the number of classes. Gini reaches zero when all cases in the node fall into a single target category. . Alternatively, one can use information gain to decide where to split, where information gain is defined as the difference in entropy of the parent and the weighted sum of the entropies of the children. Entropy is defined as: . $H_(p) = - sum_{i=1}^{J}p_{i} log_{2}(p_{i})$ . Let&#39;s train a decision tree: . clf = DecisionTreeClassifier(criterion=&quot;entropy&quot;).fit(X_train, y_train) . clf.plot() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; Tree 0 X 3 ≤ 0.8 entropy = 1.581 samples = 112 value = [37, 34, 41] 1 entropy = 0.0 samples = 37 value = [37, 0, 0] 0&#45;&gt;1 True 2 X 2 ≤ 4.95 entropy = 0.994 samples = 75 value = [0, 34, 41] 0&#45;&gt;2 False 3 X 3 ≤ 1.65 entropy = 0.414 samples = 36 value = [0, 33, 3] 2&#45;&gt;3 8 X 2 ≤ 5.05 entropy = 0.172 samples = 39 value = [0, 1, 38] 2&#45;&gt;8 4 entropy = 0.0 samples = 32 value = [0, 32, 0] 3&#45;&gt;4 5 X 1 ≤ 3.1 entropy = 0.811 samples = 4 value = [0, 1, 3] 3&#45;&gt;5 6 entropy = 0.0 samples = 3 value = [0, 0, 3] 5&#45;&gt;6 7 entropy = 0.0 samples = 1 value = [0, 1, 0] 5&#45;&gt;7 9 X 0 ≤ 6.5 entropy = 0.811 samples = 4 value = [0, 1, 3] 8&#45;&gt;9 12 entropy = 0.0 samples = 35 value = [0, 0, 35] 8&#45;&gt;12 10 entropy = 0.0 samples = 3 value = [0, 0, 3] 9&#45;&gt;10 11 entropy = 0.0 samples = 1 value = [0, 1, 0] 9&#45;&gt;11 Here&#39;s the training score which indeed shows the tree is perfect at classfying the flowers on the training set. This tends to result in overfitting to the training set. . clf.score(X_train, y_train) . 1.0 . This is an easy dataset to classify, so the overfitting is not evident here. . clf.score(X_test, y_test) . 0.9736842105263158 . There are 7 leaves in our tree. Note that the leaves do not have to be depicted at the bottom of the tree in the diagram. A leaf is just a node without any children and could be represented near the top of the tree. . clf.get_n_leaves() . 7 . Inference . Now that we have trained our model, we can perform inference. . When inference on new samples is performed, the sample simply is examined with the &quot;rules&quot; created by the feature splits. Starting from the topmost node (the root node) in our example above, if feature three has a value of less than or equal 0.8, go to the left child node; otherwise go to the right. This process continues all the way down until the sample is put into a leaf. . The predicted class is the class in the leaf with the highest probability of that class for that leaf. In other words, simply break down the training samples by class within that leaf and choose the class with the most number of train samples. The probability of choosing that class is simply the number of training samples in that leaf belonging to that class divided by the total number of training samples in that leaf. . Since all of our leafs are pure, the classifier will always give 100% for its predictions. We&#39;ll rexamine this when we have impure leafs below. . Here are the features for the first test sample. . X_test[0] . array([5.8, 2.8, 5.1, 2.4]) . The path for this sample follows down the right side of the tree. Note that features are zero-indexed. . Root node: Is 2.4 &lt;= 0.8? No, so go right. . Is 5.1 &lt;= 4.95? No, so go right. . Is 5.1 &lt;= 5.05? No, so go right. . That brings it to the leaf on the right with 35 samples, where the 3rd class (index 2) is predicted: . clf.predict([X_test[0]]) . array([2]) . Again, the probability is 100% since there are no training samples in that leaf from the other two classes. In the plot the node is colored dark purple. For this tree purple represents the 3rd class and the darker the shade the more probable it is. . clf.predict_proba([X_test[0]]) . array([[0., 0., 1.]]) . Pruning . One way to prevent overfitting is the pre-prune the tree by specifying the maximum depth and/or maximum number of leaves. Here we set the maximum depth to 3. . clf = DecisionTreeClassifier(max_depth=3, random_state=0, criterion=&quot;entropy&quot;).fit(X_train, y_train) . clf.plot() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; Tree 0 X 3 ≤ 0.8 entropy = 1.581 samples = 112 value = [37, 34, 41] 1 entropy = 0.0 samples = 37 value = [37, 0, 0] 0&#45;&gt;1 True 2 X 2 ≤ 4.95 entropy = 0.994 samples = 75 value = [0, 34, 41] 0&#45;&gt;2 False 3 X 3 ≤ 1.65 entropy = 0.414 samples = 36 value = [0, 33, 3] 2&#45;&gt;3 6 X 2 ≤ 5.05 entropy = 0.172 samples = 39 value = [0, 1, 38] 2&#45;&gt;6 4 entropy = 0.0 samples = 32 value = [0, 32, 0] 3&#45;&gt;4 5 entropy = 0.811 samples = 4 value = [0, 1, 3] 3&#45;&gt;5 7 entropy = 0.811 samples = 4 value = [0, 1, 3] 6&#45;&gt;7 8 entropy = 0.0 samples = 35 value = [0, 0, 35] 6&#45;&gt;8 clf.score(X_train, y_train) . 0.9821428571428571 . clf.score(X_test, y_test) . 0.9736842105263158 . Here is a sample where we are only 75% sure that it is class 2, since only 3 of the 4 samples in its leaf are class 2. . clf.predict([X_test[20]]) . array([2]) . clf.predict_proba([X_test[20]]) . array([[0. , 0.25, 0.75]]) . How a classification tree determines where to split . Let&#39;s talk a little bit more about how trees use entropy (or alternatively Gini) to determine splits. . Information gain is calculated by cycling through all possible splits in the training set. Practically this is the process: . Select the first feature. | Pick the halfway point between the first sample and the second sample. | Calculate the entropy of the two child nodes if a split is made at that point. | Repeat steps 2 and 3 for all midpoints for this feature. | Go back to step 1 and repeat for all features. | At the end, pick the feature and split that has the lowest sum entropy for the two child nodes. . Again, information gain is the difference in entropy of the parent node and the summation of entropies of the two child nodes. Since the entropy of the parent node is the same for each potential split that we try, we only need to calculate the entropies of the child nodes for a split and find the split that minimizes that since that will maximize the information gained. . Here&#39;s a tree with a max depth of 1 using entropy to split: . clf = DecisionTreeClassifier(random_state=42, max_depth=1, criterion=&quot;entropy&quot;).fit(X_train, y_train) . clf.plot() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; Tree 0 X 2 ≤ 2.35 entropy = 1.581 samples = 112 value = [37, 34, 41] 1 entropy = 0.0 samples = 37 value = [37, 0, 0] 0&#45;&gt;1 True 2 entropy = 0.994 samples = 75 value = [0, 34, 41] 0&#45;&gt;2 False Let&#39;s implement our entropy calculation. This takes a list of targets and calculates the entropy for that node. . from collections import Counter def entropy(values): total = values.shape[0] c = Counter(values) if total == 0: return 0 s = 0 for x in c.values(): p = x/total s += p * np.log2(p) return -s . Here&#39;s our original list of targets: . y_train . array([1, 1, 2, 0, 2, 0, 0, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 0, 2, 1, 1, 1, 1, 2, 0, 0, 2, 1, 0, 0, 1, 0, 2, 1, 0, 1, 2, 1, 0, 2, 2, 2, 2, 0, 0, 2, 2, 0, 2, 0, 2, 2, 0, 0, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 1, 0, 0, 1, 0, 2, 1, 2, 1, 0, 2, 0, 2, 0, 0, 2, 0, 2, 1, 1, 1, 2, 2, 1, 1, 0, 1, 2, 2, 0, 1, 1, 1, 1, 0, 0, 0, 2, 1, 2, 0]) . Here&#39;s the associated entropy which matches above. This is the entropy of the root node. . entropy(y_train) . 1.5807197138422104 . Now let&#39;s get the entropes of the child nodes for the split that was found. In this case it was feature 3 with the split at 0.8. . feat = 3 x = 0.8 . Here are the samples that went into the left node. As you can see all of them are of class 0. There is no entropy associated with this node - the node is pure. . left = y_train[X_train[:,feat] &lt;= x] left . array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) . entropy(left) . -0.0 . Here are the samples that went into the right node: . right = y_train[X_train[:,feat] &gt; x] right . array([1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2]) . entropy(right) . 0.993707106604508 . Now we need the cycle through each feature, and then cycle through each possible split. . import math def calc_entropies(X, y): n = y.shape[0] m = X.shape[1] min_ents = np.zeros(m) min_splits = np.zeros(m) for feat in range(m): # Use set to remove dups; sort it to get halfway points points = sorted(list(set(X[:,feat]))) splits = [(points[i-1]+points[i])/2. for i in range(1, len(points))] entropies = [] for x in splits: l = y_train[X_train[:,feat] &lt;= x] r = y_train[X_train[:,feat] &gt; x] e = (l.shape[0]*entropy(l) + r.shape[0]*entropy(r)) / n entropies.append(e) feat_min_ent = np.argmin(entropies) min_ents[feat] = entropies[feat_min_ent] min_splits[feat] = splits[feat_min_ent] min_feat = np.argmin(min_ents) return min_feat, min_splits[min_feat], min_ents[min_feat] . calc_entropies(X_train, y_train) . (2, 2.35, 0.6654288660298044) . Note that in this example splitting feature 3 at 0.8 gives the same entropy as the above split. np.argmin returns the argument of the first minimum in the case of a tie. . Regression . I&#39;ll cover decision tree regression in another post soon. .",
            "url": "https://barnett.science/machinelearning/2020/05/14/decision-trees.html",
            "relUrl": "/machinelearning/2020/05/14/decision-trees.html",
            "date": " • May 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I solve business problems through the end-to-end implementation of machine learning products. . I received a BS in Mechanical Engineering from Mississippi State University. Later, I received a PhD in Chemical &amp; Molecular Engineering from Tulane University where the focus on my research was on molecular simulations. After that I was a postdoctoral research scientist at Columbia University where I studied polymer interactions using molecular simulations and machine learning. . More recently I was a fellow with Insight Data Science where I created a Chrome Extension to predict where a user would post their content. I currently am in a senior machine learning engineer role at a financial company. .",
          "url": "https://barnett.science/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://barnett.science/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}